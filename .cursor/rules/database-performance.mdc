---
description:
globs:
alwaysApply: true
---
# Database Architecture & Performance

## **Migration Best Practices**

- **Safe Constraints**: Use `restrict_with_error` instead of `dependent: :destroy` for data safety
- **Foreign Key Constraints**: Always add proper referential integrity constraints
- **Database Indexes**: Index all foreign keys and frequently queried columns
- **Default Data**: Create essential default records (boards, statuses) in migrations
- **Reversible Migrations**: Ensure all migrations are properly reversible

```ruby
# ✅ DO: Safe migration with proper constraints
class CreateFeedbackBoardTickets < ActiveRecord::Migration[7.0]
  def change
    create_table :feedback_board_tickets do |t|
      t.string :title, null: false
      t.text :description
      t.string :status, default: 'open'
      t.boolean :locked, default: false
      t.references :board, null: false, foreign_key: { to_table: :feedback_board_boards }
      t.references :user, polymorphic: true, null: true
      t.timestamps null: false
    end

    add_index :feedback_board_tickets, [:board_id, :status]
    add_index :feedback_board_tickets, [:board_id, :created_at]
    add_index :feedback_board_tickets, :user_id
  end
end
```

## **Sluggable Concern Implementation**

- **Smart Find Method**: Override `.find()` to handle both slugs and IDs transparently
- **Performance Optimization**: Try slug lookup first (most common case), fallback to ID
- **Error Handling**: Provide contextual error messages for missing records
- **URL Generation**: Use `to_param` to return slug for clean URLs
- **Backwards Compatibility**: Support existing ID-based lookups seamlessly

```ruby
# ✅ DO: Enhanced Sluggable concern
module FeedbackBoard::Sluggable
  extend ActiveSupport::Concern

  class_methods do
    def find(param)
      find_by_slug_or_id!(param)
    end

    def find_by_slug_or_id(param)
      return nil if param.blank?

      # Try slug first (most common case)
      record = find_by(slug: param.to_s)
      return record if record

      # Fallback to ID if param looks like an integer
      return find_by(id: param) if param.to_s.match?(/\A\d+\z/)

      nil
    end

    def find_by_slug_or_id!(param)
      find_by_slug_or_id(param) ||
        raise(ActiveRecord::RecordNotFound, "Couldn't find #{name} with slug or id '#{param}'")
    end
  end

  def to_param
    slug
  end
end
```

## **Database Indexing Strategy**

- **Foreign Key Indexes**: Index all `belongs_to` relationships
- **Composite Indexes**: Use multi-column indexes for common query patterns
- **Search Optimization**: Index searchable text columns with appropriate strategies
- **Performance Monitoring**: Regular index usage analysis and optimization

```ruby
# ✅ DO: Strategic index placement
# Most common queries for tickets:
add_index :feedback_board_tickets, [:board_id, :status]        # Board filtering
add_index :feedback_board_tickets, [:board_id, :created_at]    # Recent tickets
add_index :feedback_board_tickets, [:user_id]                 # User's tickets
add_index :feedback_board_tickets, [:board_id, :title]        # Search optimization

# Comment threading performance:
add_index :feedback_board_comments, [:ticket_id, :parent_id]  # Thread loading
add_index :feedback_board_comments, [:parent_id]              # Reply lookup
add_index :feedback_board_comments, [:ticket_id, :created_at] # Chronological order
```

## **Query Optimization Patterns**

- **N+1 Prevention**: Use `includes` for association preloading
- **Scoped Queries**: Build efficient, composable query scopes
- **Database-Agnostic Search**: Support PostgreSQL, MySQL, and SQLite search patterns
- **Pagination Ready**: Structure queries for efficient pagination
- **Count Optimization**: Use `counter_caches` for frequently accessed counts

```ruby
# ✅ DO: Optimized query patterns
class Ticket < ApplicationRecord
  scope :with_associations, -> { includes(:user, :board, comments: :user) }
  scope :recent, -> { order(created_at: :desc) }
  scope :popular, -> { left_joins(:upvotes).group(:id).order('COUNT(feedback_board_upvotes.id) DESC') }
  scope :search, ->(term) {
    return all if term.blank?

    # Database-agnostic search
    if connection.adapter_name.downcase.include?('postgresql')
      where("title ILIKE ? OR description ILIKE ?", "%#{term}%", "%#{term}%")
    else
      where("LOWER(title) LIKE ? OR LOWER(description) LIKE ?",
            "%#{term.downcase}%", "%#{term.downcase}%")
    end
  }
end
```

## **Data Integrity Patterns**

- **Validation Strategy**: Comprehensive model validations with database constraints
- **Referential Integrity**: Foreign key constraints to prevent orphaned records
- **Data Migration Safety**: Preserve existing data during schema changes
- **Constraint Violations**: Graceful handling of database constraint errors

```ruby
# ✅ DO: Multi-layer data protection
class Board < ApplicationRecord
  validates :name, presence: true, length: { maximum: 100 }
  validates :slug, presence: true, uniqueness: true, format: {
    with: /\A[a-z0-9\-]+\z/,
    message: 'only lowercase letters, numbers, and hyphens allowed'
  }

  has_many :tickets, dependent: :restrict_with_error

  before_validation :generate_slug_from_name, if: -> { slug.blank? && name.present? }
end
```

## **Performance Monitoring**

- **Query Analysis**: Regular review of slow query logs
- **Index Usage**: Monitor index effectiveness and usage patterns
- **Memory Usage**: Track memory consumption for large result sets
- **Cache Strategy**: Implement appropriate caching at model and view levels
- **Background Processing**: Use background jobs for expensive operations

## **Search Implementation**

- **Full-Text Search**: Implement database-appropriate search strategies
- **Search Indexing**: Consider search-specific indexes for performance
- **Multi-Table Search**: Efficient searching across tickets, descriptions, and comments
- **Search Scoping**: Limit search to appropriate board context
- **Search Performance**: Monitor and optimize search query performance

## **Upvote System Optimization**

- **Unique Constraints**: Database-level uniqueness for user/votable combinations
- **Polymorphic Performance**: Proper indexing for polymorphic associations
- **Vote Counting**: Efficient vote count queries and caching strategies
- **Vote Tracking**: Audit trails for vote changes if needed

Reference: @directive.md Database & Performance sections for complete optimization strategies
